---
- name: Find AAP Installation Host
  hosts: all
  gather_facts: no
  tasks:
    - name: Check for AAP installation directory
      stat:
        path: "/home/aap/ansible-automation-platform-containerized-setup-bundle-2.6-1.1-x86_64"
      register: aap_dir_check
      ignore_errors: yes

    - name: Search for AAP directory if default doesn't exist
      find:
        paths: 
          - /home
          - /opt
          - /root
        patterns: "ansible-automation-platform-containerized-setup-bundle*"
        file_type: directory
        recurse: yes
        depth: 3
      register: aap_search
      when: not aap_dir_check.stat.exists
      ignore_errors: yes

    - name: Register host with AAP installation
      set_fact:
        has_aap: true
        aap_path: "{{ aap_dir_check.stat.path if aap_dir_check.stat.exists else (aap_search.files[0].path if aap_search.files is defined and aap_search.files | length > 0 else '') }}"
      when: aap_dir_check.stat.exists or (aap_search.files is defined and aap_search.files | length > 0)

- name: Restore Ansible Automation Platform
  hosts: all
  gather_facts: yes
  vars:
    restore_log_dir: "/var/log/aap-backups"
    # These variables should be set via AAP Survey:
    # backup_timestamp: ""  # Format: YYYYMMDD_HHMMSS or "latest"
    # confirm_restore: "no"  # Must be "yes" to proceed
  tasks:
    - name: Skip hosts without AAP installation
      meta: end_host
      when: has_aap is not defined or not has_aap

    - name: Verify confirmation
      fail:
        msg: |
          ⚠️ RESTORE NOT CONFIRMED ⚠️
          
          You must set 'confirm_restore' to 'yes' in the survey to proceed.
          This is a safety measure to prevent accidental restores.
      when: confirm_restore | default('no') | lower != 'yes'

    - name: Get list of available backups
      find:
        paths: "{{ aap_path }}/backups"
        file_type: directory
        patterns: "202*"
      register: available_backups
      become: yes
      become_user: aap

    - name: Fail if no backups found
      fail:
        msg: "❌ No backups found in {{ aap_path }}/backups/"
      when: available_backups.matched == 0

    - name: Sort backups by name (newest first)
      set_fact:
        sorted_backups: "{{ available_backups.files | sort(attribute='path', reverse=true) }}"

    - name: Display available backups
      debug:
        msg: 
          - "=== Available Backups ==="
          - "{% for backup in sorted_backups %}  {{ loop.index }}. {{ backup.path | basename }}{% endfor %}"

    - name: Use most recent backup if 'latest' specified
      set_fact:
        backup_timestamp: "{{ sorted_backups[0].path | basename }}"
      when: backup_timestamp | default('latest') | lower == 'latest'

    - name: Set restore backup path
      set_fact:
        restore_backup_path: "{{ aap_path }}/backups/{{ backup_timestamp }}"

    - name: Verify backup directory exists
      stat:
        path: "{{ restore_backup_path }}"
      register: backup_dir_check
      become: yes
      become_user: aap

    - name: Fail if backup directory doesn't exist
      fail:
        msg: |
          ❌ Backup directory not found: {{ restore_backup_path }}
          
          Available backups:
          {% for backup in sorted_backups %}
            - {{ backup.path | basename }}
          {% endfor %}
      when: not backup_dir_check.stat.exists

    - name: List backup files
      find:
        paths: "{{ restore_backup_path }}"
        patterns: "*.tar.gz"
      register: backup_files
      become: yes
      become_user: aap

    - name: Fail if no backup files found
      fail:
        msg: "❌ No backup files (*.tar.gz) found in {{ restore_backup_path }}"
      when: backup_files.matched == 0

    - name: Display restore configuration
      debug:
        msg:
          - "╔════════════════════════════════════════════════════════╗"
          - "║         AAP RESTORE OPERATION STARTING                 ║"
          - "╚════════════════════════════════════════════════════════╝"
          - ""
          - "Host:           {{ inventory_hostname }}"
          - "AAP Directory:  {{ aap_path }}"
          - "Backup:         {{ backup_timestamp }}"
          - "Files Found:    {{ backup_files.matched }}"
          - ""
          - "Files to restore:"
          - "{% for file in backup_files.files %}  ✓ {{ file.path | basename }} ({{ (file.size / 1024 / 1024) | round(2) }} MB){% endfor %}"
          - ""
          - "⚠️  This will REPLACE current AAP data with backup data!"

    - name: Create restore log directory
      file:
        path: "{{ restore_log_dir }}"
        state: directory
        mode: '0755'
      become: yes

    - name: Get restore timestamp
      set_fact:
        restore_timestamp: "{{ lookup('pipe', 'date +%Y%m%d_%H%M%S') }}"

    - name: Copy backup files to AAP backups directory
      copy:
        src: "{{ item.path }}"
        dest: "{{ aap_path }}/backups/{{ item.path | basename }}"
        remote_src: yes
        owner: aap
        group: aap
        mode: '0644'
      loop: "{{ backup_files.files }}"
      become: yes
      become_user: aap

    - name: Run AAP containerized restore
      shell: |
        cd {{ aap_path }}
        ansible-playbook -i inventory ansible.containerized_installer.restore 2>&1
      args:
        chdir: "{{ aap_path }}"
        executable: /bin/bash
      become: yes
      become_user: aap
      register: restore_result
      changed_when: true
      failed_when: false

    - name: Save restore log
      copy:
        content: |
          AAP Restore Execution Log
          =========================
          Host: {{ inventory_hostname }}
          Date: {{ ansible_date_time.date }}
          Time: {{ ansible_date_time.time }}
          AAP Directory: {{ aap_path }}
          Backup Restored: {{ backup_timestamp }}
          Backup Path: {{ restore_backup_path }}
          Return Code: {{ restore_result.rc }}
          
          === FILES RESTORED ===
          {% for file in backup_files.files %}
          - {{ file.path | basename }} ({{ (file.size / 1024 / 1024) | round(2) }} MB)
          {% endfor %}
          
          === COMMAND ===
          cd {{ aap_path }}
          ansible-playbook -i inventory ansible.containerized_installer.restore
          
          === OUTPUT ===
          {{ restore_result.stdout }}
          
          === ERRORS ===
          {{ restore_result.stderr }}
        dest: "{{ restore_log_dir }}/restore_{{ restore_timestamp }}_from_{{ backup_timestamp }}.log"
        mode: '0644'
      become: yes

    - name: Display restore output summary (first 40 lines)
      debug:
        msg: "{{ restore_result.stdout_lines[:40] }}"
      when: restore_result.stdout_lines is defined

    - name: Display result
      debug:
        msg:
          - "╔════════════════════════════════════════════════════════╗"
          - "║         RESTORE OPERATION COMPLETE                     ║"
          - "╚════════════════════════════════════════════════════════╝"
          - ""
          - "Host:           {{ inventory_hostname }}"
          - "Backup:         {{ backup_timestamp }}"
          - "Return Code:    {{ restore_result.rc }}"
          - "Log File:       {{ restore_log_dir }}/restore_{{ restore_timestamp }}_from_{{ backup_timestamp }}.log"

    - name: Success message
      debug:
        msg:
          - "✓✓✓ RESTORE COMPLETED SUCCESSFULLY ✓✓✓"
          - ""
          - "AAP has been restored from backup {{ backup_timestamp }}"
          - "Please verify AAP services are running correctly."
      when: restore_result.rc == 0

    - name: Error message
      debug:
        msg:
          - "❌❌❌ RESTORE ENCOUNTERED ERRORS ❌❌❌"
          - ""
          - "Return Code: {{ restore_result.rc }}"
          - "Check log file: {{ restore_log_dir }}/restore_{{ restore_timestamp }}_from_{{ backup_timestamp }}.log"
          - ""
          - "You may need to manually investigate and retry the restore."
      when: restore_result.rc != 0

    - name: Fail if critical error
      fail:
        msg: "Restore failed critically with return code {{ restore_result.rc }}"
      when: restore_result.rc != 0 and restore_result.rc > 2

    - name: Verify AAP services status
      shell: |
        cd {{ aap_path }}
        podman ps --format "table {{{{.Names}}}}\t{{{{.Status}}}}" 2>&1
      register: services_status
      become: yes
      become_user: aap
      when: restore_result.rc == 0
      ignore_errors: yes

    - name: Display services status
      debug:
        msg:
          - "=== AAP Services Status ==="
          - "{{ services_status.stdout }}"
      when: restore_result.rc == 0 and services_status.stdout is defined
